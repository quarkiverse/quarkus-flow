<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8"/>
    <title>Newsletter – Human Review</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@1.5.10/css/pico.min.css">
    <style>
        body { padding-block: 2rem; }
        pre { white-space: pre-wrap; }
        .stack { display: grid; gap: 1rem; }
        .pill { background: var(--muted-border-color); border-radius: 999px; padding: .1rem .5rem; font-size: .8rem; }
        .muted { opacity: .75; }
        .draft-preview { background: var(--card-sectionning-background-color); padding: .75rem; border-radius: .5rem; min-height: 8rem; }
        .spinner { width:1rem; height:1rem; border:2px solid var(--muted-border-color); border-top-color: var(--primary); border-radius:50%; animation: spin .8s linear infinite; display:inline-block; vertical-align: middle; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .row { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
        .scores { display: grid; grid-template-columns: repeat(auto-fit, minmax(110px,1fr)); gap: .5rem; }
        .score { border: 1px solid var(--muted-border-color); border-radius: .5rem; padding: .5rem; text-align: center; }
        .badge { background: var(--primary); color: #fff; border-radius: .5rem; padding: .15rem .5rem; font-size: .85rem; }
        .success { background: var(--primary); }
        .warn { background: #f59e0b; color: #000; }
        .ghost { background: var(--muted-border-color); color: var(--muted-color); }
        .separator { height:1px; background: var(--muted-border-color); margin:.25rem 0 .5rem; }
        .overlay { position: fixed; inset: 0; z-index: 9999; background: color-mix(in srgb, var(--background-color) 65%, #0000); display: grid; place-items: center; padding: 2rem; }
        .overlay.hidden { display: none; }
        .overlay-card { background: var(--card-background-color); border: 1px solid var(--muted-border-color); border-radius: .75rem; padding: 1.25rem 1.5rem; box-shadow: 0 8px 24px rgba(0,0,0,.12); text-align: center; }
        .overlay .spinner { width: 1.25rem; height: 1.25rem; margin-right: .5rem; }
        .banner { border-radius: .75rem; padding: .75rem 1rem; margin: 1rem 0; border: 1px solid var(--muted-border-color); background: color-mix(in srgb, var(--success-600) 10%, var(--card-background-color)); }
        .banner.success { border-color: var(--success-600); }
    </style>
</head>
<body>
<div id="overlay" class="overlay hidden" aria-live="assertive" aria-busy="true">
    <div class="overlay-card">
        <p style="margin:0 0 .5rem 0;"><span class="spinner"></span><strong id="overlayMsg">Submitting review…</strong></p>
        <small class="muted">Waiting for the agent’s next update</small>
    </div>
</div>

<main class="container">
    <header>
        <h1>Human Review</h1>
        <p class="muted">Loads the most recent review (cache first), then live-updates via WebSocket.</p>
    </header>

    <article id="currentReview" class="stack">
        <header class="row" style="align-items:center;">
            <div><strong>Latest review</strong></div>
            <div style="justify-self:end;">
                <span id="statusBadge" class="pill">loading <span class="spinner"></span></span>
            </div>
        </header>

        <label>
            Draft (from critic / latest round)
            <div id="draft" class="draft-preview">(loading…)</div>
        </label>

        <details id="criticDetails" open>
            <summary>Critic details</summary>
            <div class="stack">
                <div class="row">
                    <div>
                        <small class="muted">Verdict</small><br/>
                        <span id="verdictBadge" class="badge ghost">—</span>
                    </div>
                    <div>
                        <small class="muted">Overall score</small><br/>
                        <span id="overallScore" class="badge ghost">—</span>
                    </div>
                </div>

                <div class="separator"></div>

                <div class="row">
                    <div>
                        <small class="muted">Reasons</small>
                        <ul id="reasonsList" class="muted" style="margin:.25rem 0 0 1rem;">
                            <li>—</li>
                        </ul>
                    </div>
                    <div>
                        <small class="muted">Suggestions</small>
                        <ul id="suggestionsList" class="muted" style="margin:.25rem 0 0 1rem;">
                            <li>—</li>
                        </ul>
                    </div>
                </div>

                <div>
                    <small class="muted">Scores</small>
                    <div id="scoresGrid" class="scores"></div>
                </div>
            </div>
        </details>
    </article>

    <article>
        <div id="doneBanner" class="banner success" style="display:none">
            ✅ Review finished. Workflow moved to the “send newsletter” step.
        </div>
        <form id="reviewForm" class="stack">
            <div class="row">
                <label>
                    Status
                    <select name="status" required>
                        <option value="NEEDS_REVISION">NEEDS_REVISION</option>
                        <option value="DONE">DONE</option>
                    </select>
                </label>
                <label>
                    Notes (optional)
                    <input name="notes" placeholder="Your suggestions or approval note">
                </label>
            </div>

            <label>
                Draft to submit
                <textarea name="draft" id="draftInput" rows="8" placeholder="Edit the draft if needed…"></textarea>
            </label>

            <footer class="row">
                <button id="submitBtn" type="submit">
                    <span id="submitLabel">Submit review</span>
                    <span id="submitSpinner" class="spinner" style="display:none;margin-left:.5rem;"></span>
                </button>
                <a class="secondary" href="/index.html" style="justify-self:end;">Back to compose</a>
            </footer>
        </form>
    </article>
</main>

<script>
    // ---------- DOM refs ----------
    const draftEl = document.getElementById('draft');
    const verdictBadge = document.getElementById('verdictBadge');
    const overallScoreEl = document.getElementById('overallScore');
    const reasonsList = document.getElementById('reasonsList');
    const suggestionsList = document.getElementById('suggestionsList');
    const scoresGrid = document.getElementById('scoresGrid');

    const statusBadge = document.getElementById('statusBadge');
    const draftInput = document.getElementById('draftInput');
    const reviewForm = document.getElementById('reviewForm');
    const submitBtn = document.getElementById('submitBtn');
    const submitLabel = document.getElementById('submitLabel');
    const submitSpinner = document.getElementById('submitSpinner');

    const notesInput = reviewForm.querySelector('input[name="notes"]');

    const overlay = document.getElementById('overlay');
    const overlayMsg = document.getElementById('overlayMsg');

    const doneBanner = document.getElementById('doneBanner');

    // ---------- Cache key ----------
    const LATEST_REVIEW_CACHE_KEY = 'newsletter.latestReview';

    // ---------- Overlay / loading ----------
    function showOverlay(msg = 'Submitting review…') {
        overlayMsg.textContent = msg;
        overlay.classList.remove('hidden');
    }
    function hideOverlay() { overlay.classList.add('hidden'); }

    let awaitingWsAfterSubmit = false;
    let finalizeTimerId = null;

    function setFormLoading(isLoading, labelTextSending = 'Submitting…') {
        submitBtn.disabled = isLoading;
        submitSpinner.style.display = isLoading ? 'inline-block' : 'none';
        submitLabel.textContent = isLoading ? labelTextSending : 'Submit review';
        [...reviewForm.elements].forEach(el => el.disabled = isLoading && el !== submitBtn);
    }

    function setBadgeLoading(text) {
        statusBadge.innerHTML = `${text} <span class="spinner"></span>`;
    }
    function clearBadge(text) { statusBadge.textContent = text; }

    function arrayOrEmpty(v) { return Array.isArray(v) ? v : (v ? [v] : []); }
    function safe(obj, ...keys) {
        return keys.reduce((acc, k) => (acc && acc[k] !== undefined ? acc[k] : undefined), obj);
    }

    function setList(ul, items) {
        ul.innerHTML = '';
        if (!items || items.length === 0) { ul.innerHTML = '<li>—</li>'; return; }
        items.forEach(i => {
            const li = document.createElement('li');
            li.textContent = String(i);
            ul.appendChild(li);
        });
    }

    function setScores(scores) {
        scoresGrid.innerHTML = '';
        if (!scores || typeof scores !== 'object') {
            scoresGrid.innerHTML = '<div class="score muted">No scores</div>';
            return;
        }
        Object.entries(scores).forEach(([k, v]) => {
            const d = document.createElement('div');
            d.className = 'score';
            d.innerHTML = `<div style="font-size:.8rem;" class="muted">${k}</div><div style="font-size:1.1rem;"><strong>${v}</strong></div>`;
            scoresGrid.appendChild(d);
        });
    }

    function setVerdict(v) {
        if (!v) { verdictBadge.className = 'badge ghost'; verdictBadge.textContent = '—'; return; }
        const normalized = String(v).toLowerCase();
        verdictBadge.textContent = v;
        verdictBadge.className = 'badge ' + (normalized === 'approve' ? 'success' : 'warn');
    }

    function applyReview(reviewObj) {
        const candidate = reviewObj.revised_draft || reviewObj.revisedDraft ||
            reviewObj.original_draft || reviewObj.originalDraft || '';

        draftEl.textContent = candidate || '(empty)';
        draftInput.value = candidate || '';

        setVerdict(reviewObj.verdict);
        setList(reasonsList, arrayOrEmpty(reviewObj.reasons));
        setList(suggestionsList, arrayOrEmpty(reviewObj.suggestions));
        setScores(reviewObj.scores);

        const overall = safe(reviewObj, 'scores', 'overall');
        overallScoreEl.textContent = overall != null ? String(overall) : '—';
        overallScoreEl.className = overall != null ? 'badge' : 'badge ghost';
    }

    // ---------- Cache helpers ----------
    function saveCachedReview(obj) {
        try { localStorage.setItem(LATEST_REVIEW_CACHE_KEY, JSON.stringify({ ts: Date.now(), payload: obj })); } catch {}
    }
    function readCachedReview() {
        try {
            const raw = localStorage.getItem(LATEST_REVIEW_CACHE_KEY);
            if (!raw) return null;
            const parsed = JSON.parse(raw);
            return parsed && parsed.payload ? parsed.payload : null;
        } catch { return null; }
    }
    function clearCachedReview() { try { localStorage.removeItem(LATEST_REVIEW_CACHE_KEY); } catch {} }

    // ---------- DONE flow helpers ----------
    let ws; // global socket

    function disableForm() {
        [...reviewForm.elements].forEach(el => el.disabled = true);
        submitBtn.disabled = true;
    }
    function showDoneBanner() { doneBanner.style.display = ''; }
    function hideDoneBanner() { doneBanner.style.display = 'none'; }

    function closeSocket() {
        try { if (ws && ws.readyState === WebSocket.OPEN) ws.close(1000, 'completed'); } catch {}
    }

    function completeRun() {
        hideOverlay();
        setFormLoading(false);
        clearBadge('completed');
        disableForm();
        showDoneBanner();
        closeSocket();
        clearCachedReview();
    }

    // ---------- Initial load from cache, fallback API ----------
    async function loadFromCacheOrApi() {
        const cached = readCachedReview();
        if (cached) {
            applyReview(cached);
            clearBadge('loaded from cache');
            if ((cached.status || '').toUpperCase() === 'DONE') {
                completeRun();
            }
            return;
        }
        // Optional server fallback (if you kept this endpoint)
        try {
            setBadgeLoading('loading from server');
            const res = await fetch('/api/newsletter/reviews/latest?limit=1', { cache: 'no-store' });
            if (res.ok) {
                const arr = await res.json(); // [{received, payload}]
                if (Array.isArray(arr) && arr.length > 0 && arr[0].payload) {
                    const payload = JSON.parse(arr[0].payload);
                    applyReview(payload);
                    saveCachedReview(payload);
                    clearBadge('loaded from server');
                    if ((payload.status || '').toUpperCase() === 'DONE') completeRun();
                    return;
                }
            }
            clearBadge('no review yet');
            draftEl.textContent = '(no review yet)';
        } catch { clearBadge('load failed'); }
    }

    // ---------- WS loader badge ----------
    function flashUpdatingBadge() {
        setBadgeLoading('updating from agent');
        setTimeout(() => {
            if (!awaitingWsAfterSubmit) clearBadge('live');
        }, 1200);
    }

    // ---------- WebSocket ----------
    function openWs() {
        const wsUrl = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/ws/newsletter';
        ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            if (!awaitingWsAfterSubmit) clearBadge('live (WS connected)');
        };
        ws.onclose = () => clearBadge('WS disconnected');

        ws.onmessage = (ev) => {
            try {
                flashUpdatingBadge();
                const review = JSON.parse(ev.data);
                applyReview(review);

                // If this was a post-submit wait, clear the notes as before:
                if (awaitingWsAfterSubmit) {
                    if (notesInput) notesInput.value = '';
                    setFormLoading(false);
                    awaitingWsAfterSubmit = false;
                    hideOverlay();
                    clearBadge('updated');
                }

                // If the agent confirms DONE, finalize and cancel fallback timer
                if ((review.status || '').toUpperCase() === 'DONE') {
                    clearTimeout(finalizeTimerId);
                    completeRun();
                }
            } catch (_) { /* ignore */ }
        };
    }

    // ---------- Submit ----------
    reviewForm.addEventListener('submit', async (e) => {
        e.preventDefault();

        // 1) Read the form BEFORE disabling anything
        const fd = new FormData(reviewForm);
        const draft = String(fd.get('draft') ?? '').trim();
        const notes = String(fd.get('notes') ?? '');
        const status = String(fd.get('status') ?? '').toUpperCase().trim();

        // Simple client-side validation
        if (!status) {
            alert('Please select a status (NEEDS_REVISION or DONE).');
            return;
        }
        if (!draft) {
            alert('Draft cannot be empty.');
            return;
        }

        // 2) Now we can show loading + disable controls
        setFormLoading(true);
        awaitingWsAfterSubmit = true;

        showOverlay(status === 'DONE'
            ? 'Submitting final review… waiting for agent confirmation'
            : 'Submitting review… waiting for agent update'
        );
        setBadgeLoading('awaiting agent update…');

        const body = { draft, notes, status };

        try {
            const res = await fetch('/api/newsletter', {
                method: 'PUT',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(body)
            });
            if (!res.ok) throw new Error('HTTP ' + res.status);

            if (status === 'DONE') {
                showDoneBanner();
                disableForm();
                setBadgeLoading('finalizing… waiting for agent');
                clearTimeout(finalizeTimerId);
                finalizeTimerId = setTimeout(() => {
                    if (awaitingWsAfterSubmit) completeRun();
                }, 3000);
            }
        } catch (err) {
            setFormLoading(false);
            awaitingWsAfterSubmit = false;
            hideOverlay();
            clearBadge('submit failed');
            alert('Failed to submit review');
        }
    });


    // ---------- Boot ----------
    (async function boot() {
        setBadgeLoading('initializing');
        hideDoneBanner();
        await loadFromCacheOrApi();
        openWs();
    })();
</script>
</body>
</html>
