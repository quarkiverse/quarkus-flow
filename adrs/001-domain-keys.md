# ADR 001: Introduce Domain Keys in Quarkus Flow

## Status

**Proposed**

## Context

Quarkus Flow workflows frequently interact with external systems (HTTP services and messaging platforms) and internal components (logs, metrics, and traces).
Today, users must manually propagate business identifiers (for example, `orderId` or `accountId`) by explicitly referencing workflow data and configuring headers on individual tasks.

### CNCF Workflow Specification

```yaml
document:
  dsl: 1.0.0-alpha1
  namespace: test
  name: call-http-with-response-output
  version: 1.0.0
do:
  - postAuthors:
      call: http
      with:
       method: post
       endpoint:
         uri: http://localhost:9876/api/v1/authors
       body:
         firstName: ${.name}
         lastName: ${.surname }
      headers:
        X-Business-Value: ${ .txId }
```

### Reference in code

```java
var txId = "transactionId";
flow.instance(Map.of("txId", xpto));
```

While flexible, this approach has several drawbacks:

- Correlation is manual and error-prone
- There is no standard contract for identifier naming
- Correlation metadata is not consistently available to observability or persistence layers

To address these limitations, this ADR introduces the concept of a **domain key** and defines a standardized model for correlation metadata in Quarkus Flow.

## Decision

### Domain key definition

A **domain key** is a business-level identifier that represents the logical context of a workflow execution.

Examples include:

- `orderId`
- `accountId`
- `transactionId`

A domain key has the following characteristics:

- Defined by the user, not generated by the engine
- Stable for the lifetime of a workflow execution
- Meaningful in the business domain
- Used for correlation and observability

A domain key is **not**:

- An idempotency key
- A retry token
- A workflow instance identifier

### Location and lifecycle

The domain key is sent as **workflow input**.

This ensures that:

- The domain key is always available
- All runtime components can access it consistently

Conceptually:

```java
var instance =
    businessWorkflow.instance(
        Map.of("domainKeys", Map.of("orderId", orderId, "txId", transactionId))
    );
```

### Composed domain keys and extraction from input

Domain keys **may be composed** from structured workflow input rather than being provided as flat values.
This allows users to declaratively define how business identifiers are derived from the incoming payload, without duplicating or reshaping input data.

#### Input-driven domain key definition

Example workflow input:

```json
{
  "client": { "id": 123, "name": "Joe" },
  "order": { "id": 456, "desc": "Playstation 5 Disc" }
}
```

Example domain key configuration:

```yaml
name: my-workflow
domainKeys:
  clientId: /client/id
  orderId: /order/id
```

[!NOTE]
The domainKeys field is not part of the CNCF Workflow Specification.
It is used here purely as an illustrative example of how domain keys could be configured.

In this example:

- `clientId` is resolved from `/client/id`
- `orderId` is resolved from `/order/id`

This approach avoids manual duplication of values and simplifies handling of input data at the implementation level.

#### Extraction mechanism

The runtime engine is responsible for resolving domain keys deterministically and efficiently.

Rules:

- The extraction mechanism **MUST** be fast and deterministic
- JSON Pointer **SHOULD** be used as the default mechanism
- More expressive query languages (for example, `jq`) **MAY** be supported but are optional due to performance considerations

Resolved values are treated as opaque strings and follow the standard domain key propagation rules.

### Standard naming and propagation

To ensure consistent and predictable propagation of domain keys across protocols and integrations, Quarkus Flow defines normative mapping rules.

#### Canonical representation

Domain keys are represented internally as a `Map<String, Object>`.

**Key names:**

- **MUST** be lower camelCase
- **MUST** be stable and user-defined

**Values:**

- **MUST** be treated as opaque strings
- **MUST NOT** be modified by the engine

#### Normalization rules

When propagated outside the workflow runtime:

- Key names are split on camelCase boundaries
- Words are capitalized
- A protocol-specific prefix or format is applied

#### HTTP propagation

For HTTP tasks, each domain key is propagated as an HTTP header.

- Header name format: `X-<Domain-Key>`
- The `X-` prefix is mandatory
- Words are separated by hyphens (`-`)

Example:

```http
X-Client-Id: 123
X-Order-Id: 456
X-Flow-Instance-Id: UU123
```

#### CloudEvents propagation

For event-based tasks, domain keys are propagated as CloudEvents extension attributes.

Attribute names:

- **MUST** be lowercase
- **MUST NOT** contain separators (`-` or `_`)
- **MUST** follow CloudEvents extension attribute naming rules

#### Observability integration

Domain keys are exposed to observability components:

- Logs: structured log fields
- Metrics: metric attributes (labels/tags)
- Traces: span attributes

## Consequences

### Benefits

- Clear separation between business and technical concerns
- Consistent propagation across tasks and protocols
- Improved observability and debugging
- Foundation for persistence, replay, and audit features

### Trade-offs

- Introduces an additional conceptual layer (metadata vs data)
- Requires cross-project agreement on contracts and naming
