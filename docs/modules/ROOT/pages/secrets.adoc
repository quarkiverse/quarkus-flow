= Resolve secrets securely
:page-role: howto
include::includes/attributes.adoc[]
:page-aliases: secrets/index.adoc
:sectnums:

Quarkus Flow integrates the CNCF Workflow Secrets concept with Quarkus’ `CredentialsProvider` SPI.
Workflows reference secrets by handle in the DSL (no cleartext), while Quarkus supplies the actual credentials
from Vault/File Vault/custom providers at runtime. When no provider is present, Quarkus Flow defers to the SDK’s
**MicroProfile Config–backed** manager so you can define secrets directly in `application.properties` during dev/test.

== TL;DR

- Declare and reference secrets in the Java DSL (e.g., `use(u -> u.secrets("mySecret"))` and `${ $secret.mySecret.key }`).
- **Primary**: Provide a Quarkus `CredentialsProvider` bean (Vault, File Vault, or your own) and select it globally or per secret.
- **Fallback**: If no provider beans exist, define dotted keys in `application.properties`:
`mySecret.username=alice`, `mySecret.password=s3cr3t!`.
- Choose the provider globally or per secret using `@Named` bean names.
- If multiple providers exist with no selection, Quarkus Flow fails fast and lists available names.

== How resolution works

At runtime, Quarkus Flow provides a `SecretManager` that prefers Quarkus `CredentialsProvider`:

1. Per-secret override:
`quarkus.flow.secrets.credentials-provider-names.<secret>=<beanName>`

2. Global default:
`quarkus.flow.secrets.credentials-provider-name=<beanName>`

3. Single provider present:
If exactly one `CredentialsProvider` bean exists, it is used.

4. Zero providers present → **SDK fallback**:
Quarkus Flow does not bind its bridge `SecretManager`; the SDK resolves via MicroProfile Config (see below).

5. Else (multiple providers, no selection) → **fail fast**:
Clear error listing available `@Named` beans.

[NOTE]
====
Typical keys expected from providers (see the link:https://github.com/serverlessworkflow/specification/blob/main/dsl-reference.md#authentication[specification types]):

**Basic auth**: `username`, `password`

**Bearer token**: `token`/`access_token` (lenient fallback to `password`)

Your HTTP executor maps these keys to the correct `Authorization` header when an authentication references a secret.
====

== Configuration (CredentialsProvider path)

[source,properties]
----
# Global provider (by @Named bean)
quarkus.flow.secrets.credentials-provider-name=vault

# Per-secret provider overrides
quarkus.flow.secrets.credentials-provider-names.mySecret=file
quarkus.flow.secrets.credentials-provider-names.dbCreds=vault
----

[cols="2,3,5",options="header"]
|===
| Key | Example | Description

| quarkus.flow.secrets.credentials-provider-name
| vault
| Global @Named bean used for all secrets when not overridden.

| quarkus.flow.secrets.credentials-provider-names.<secret>
| mySecret=file
| Per-secret override: provider @Named used for the given secret handle.
|===

== Secrets via MicroProfile Config (fallback)

When **no** `CredentialsProvider` beans are present in the app, the SDK’s `ConfigManager` resolves secret keys from
**dotted properties** in `application.properties`:

[source,properties]
----
# Dotted keys: <secretHandle>.<key>=<value>
mySecret.username=alice
mySecret.password=s3cr3t!
----

This matches the SDK’s expectations; your workflow can keep using:
`${ $secret.mySecret.username }`, `${ $secret.mySecret.password }`, etc.

[IMPORTANT]
====
- The MicroProfile Config path is only used when **zero** `CredentialsProvider` beans exist.
- If you add a provider later, it becomes authoritative (per the precedence above).
====

== Java DSL examples

Declare the secret and consume it via the `$secret` expression:

[source,java]
----
include::{examples-dir}org/acme/secrets/SecretEchoFlow.java[]
----

// Example for Basic authentication with a secret:
//
// [source,java]
// ----
// @ApplicationScoped
// public class CallWithBasicAuthFlow extends Flow {
//     @Override
//     public Workflow descriptor() {
//         return workflow().use(u -> {
//             u.secrets("usernamePasswordSecret");
//             u.authentications(a -> a.basic("basicFromSecret").use("usernamePasswordSecret"));
//         })
//         .tasks(d -> d.task("fetch")
//             .callHTTP(h -> h.get()
//                 .endpoint(e -> e.uri("https://secured.example.com")
//                 .authenticationUse("basicFromSecret"))))
//         .build();
//     }
// }
// ----

== Unit test examples

=== Using a CredentialsProvider

[source,java]
----
@RegisterExtension
static final QuarkusUnitTest unit = new QuarkusUnitTest()
    .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)
    .addClass(SecretEchoFlow.class)
    .addClass(DumbCredentialsProvider.class))
    // select our @Named("dumb") provider globally
    .overrideConfigKey("quarkus.flow.secrets.credentials-provider-name", "dumb");

@Test
void resolves_secret_from_provider() {
    var handle = Arc.container().instance(WorkflowDefinition.class, Identifier.Literal.of(SecretEchoFlow.class.getName()));
    assertTrue(handle.isAvailable());

    var model = handle.get().instance().start().join();
    assertEquals("s3cr3t!", model.as(String.class).orElseThrow());
}
----

=== Using MicroProfile Config fallback (no provider beans)

[source,java]
----
@RegisterExtension
static final QuarkusUnitTest unit = new QuarkusUnitTest()
    .setArchiveProducer(() -> ShrinkWrap.create(JavaArchive.class)
        .addClass(SecretEchoFlow.class)
        // no CredentialsProvider classes added → fallback kicks in
        .addAsResource(new StringAsset(
                "mySecret.username=alice\n" +
                "mySecret.password=s3cr3t!\n"),
            "application.properties"));

@Test
void resolves_secret_from_application_properties() {
    var handle = Arc.container().instance(WorkflowDefinition.class, Identifier.Literal.of(SecretEchoFlow.class.getName()));
    assertTrue(handle.isAvailable());

    var model = handle.get().instance().start().join();
    assertEquals("s3cr3t!", model.as(String.class).orElseThrow());
}
----

== Behavior & fallback

1. **Referenced secret unresolved / no credentials found** → **Authorization error (per spec)**.
The engine treats missing secrets as an authorization failure. Your HTTP/task executor should surface this as
an authorization error (commonly HTTP `401 Unauthorized` or `403 Forbidden`, depending on the target and policy).

2. **Multiple providers, no selection** → error prompts to set global/per-secret selection and lists available names.

3. **Zero providers** → **SDK fallback** (MicroProfile Config dotted keys) is used:
`mySecret.username=...`, `mySecret.password=...`.

4. **Empty credential map from a provider** → clear error naming the provider and secret (provider path).

== Security notes

- Keep credentials out of the DSL—use handles only (e.g., `"usernamePasswordSecret"`).
- Prefer real secret stores (Vault) in production; File Vault/custom providers or MicroProfile Config are fine for dev/test.
- Quarkus Flow never logs secret values; errors include only provider/secret names.

=== Spec compliance

Per the CNCF Workflow Specification (Secret) the absence of required secret material MUST be treated as an
authorization problem. See:
https://github.com/serverlessworkflow/specification/blob/main/dsl.md#secret

== Troubleshooting

- _“CredentialsProvider @Named='X' not found”_: Ensure a bean exists with `@Named("X")` or remove the selection to use fallback.
- _Ambiguous providers_: Set `quarkus.flow.secrets.credentials-provider-name` or a per-secret override.
- _No credentials found for secret (provider path)_: Verify your provider returns the expected keys for that secret handle.
- _Fallback not triggering_: Check the classpath—**any** `CredentialsProvider` bean presence disables the fallback.
- _Authorization error when task executes_: Verify the referenced secret handle exists and resolves to the required
keys (e.g., `username`, `password`, `token`). Missing secrets are treated as **authorization failures** per spec.

== References

- Quarkus guide: link:https://quarkus.io/guides/credentials-provider[Using a Credentials Provider]
- CNCF Workflow Specification — Secrets: link:https://github.com/serverlessworkflow/specification/blob/main/dsl.md#secret[dsl.md#secret]
- CNCF Workflow Specification — Authentication: link:https://github.com/serverlessworkflow/specification/blob/main/dsl-reference.md#authentication[dsl-reference.md#authentication]
- Basic authentication reference: link:https://github.com/serverlessworkflow/specification/blob/main/dsl-reference.md#basic-authentication[basic-authentication]
