= Generate Quarkus Flow workflows from LangChain4j Agentic annotations
:description: Learn how to run your LangChain4j agentic workflows as Quarkus Flow workflows.
:page-topic-type: howto
include::includes/attributes.adoc[]

This guide shows how to declare agentic workflow patterns using the LangChain4j Agentic Workflow API
(`@SequenceAgent`, `@ParallelAgent`, …) and let Quarkus Flow generate and register them as first-class workflows.

== Choose your approach

Quarkus Flow supports three complementary ways to use LangChain4j:

. *Java DSL tasks* — call LangChain4j beans from Flow tasks via `agent(...)` or `function(...)`.
See xref:langchain4j.adoc[].
. *Annotations → generated workflows (this guide)* — declare patterns via annotations and let Quarkus Flow generate workflows.
. *Hybrid* — call an annotated agentic workflow from a larger Java DSL workflow via `function(...)`.
See <<hybrid>>.

== 1. Add the dependencies

In your Quarkus project, add:

[source,xml,subs=attributes+]
----
<dependencies>
    <!-- LangChain4j integration with Quarkus Flow -->
    <dependency>
        <groupId>io.quarkiverse.flow</groupId>
        <artifactId>quarkus-flow-langchain4j</artifactId>
    </dependency>

    <!-- Agentic workflows in Quarkus LangChain4j -->
    <dependency>
        <groupId>io.quarkiverse.langchain4j</groupId>
        <artifactId>quarkus-langchain4j-agentic</artifactId>
    </dependency>

    <!-- Choose one LangChain4j provider, for example Ollama -->
    <dependency>
        <groupId>io.quarkiverse.langchain4j</groupId>
        <artifactId>quarkus-langchain4j-ollama</artifactId>
    </dependency>
</dependencies>
----

Configure your provider as usual, for example with Ollama:

[source,properties]
----
quarkus.langchain4j.ollama.base-url=http://localhost:11434
quarkus.langchain4j.ollama.chat-model.model=llama3.2
----

== 2. Declare agentic workflows with annotations

Create a class (for example `org.acme.langchain4j.Agents`) and declare your agents and workflows:

[source,java]
----
include::{examples-dir}/org/acme/langchain4j/Agents.java[]
----

When the application starts:

* Quarkus LangChain4j creates the agent services.
* Quarkus Flow discovers the `@SequenceAgent` and `@ParallelAgent` methods.
* For each one, it generates a `WorkflowDefinition` and registers it.

== 3. Run and explore in the Dev UI

Start your application in dev mode:

[source,shell]
----
./mvnw quarkus:dev
----

Open the Dev UI in your browser (usually at `http://localhost:8080/q/dev`), then:

. Navigate to the *Quarkus Flow* card.
. You should see workflows whose names are derived from the agent service interfaces.
. Click the *play* icon of one of these workflows.

For each workflow:

* Quarkus Flow derives an input JSON Schema from the agent method parameters and
auto-generates an HTML form.
* You can submit the form to run the workflow.
* The output is displayed in the bottom panel (for example a generated story or an `EveningPlan`).
* You can switch to the *Mermaid* view to see the underlying workflow topology
(sequence or fork-join).

[[hybrid]]
== 4. Hybrid: call an annotated agentic workflow from a larger Flow

A common pattern is to keep agentic topology in annotations, but still orchestrate a bigger workflow in Quarkus Flow.
For example, you can:

* Use `@SequenceAgent` / `@ParallelAgent` to define the internal agentic pattern.
* Inject the generated agentic bean.
* Call it from a Java DSL workflow using a `function(...)` task, then continue with non-AI tasks (HTTP, messaging, timers, HITL, …).

Example:

[source,java]
----
import org.acme.langchain4j.Agents;
import io.serverlessworkflow.api.types.Workflow;
import jakarta.inject.Inject;

import static io.serverlessworkflow.fluent.func.FuncWorkflowBuilder.workflow;
import static io.serverlessworkflow.fluent.func.dsl.FuncDSL.emitJson;
import static io.serverlessworkflow.fluent.func.dsl.FuncDSL.function;
import static io.serverlessworkflow.fluent.func.dsl.FuncDSL.post;

public class OrderWorkflow extends Flow {

    @Inject
    Agents.EveningPlannerAgent eveningPlanner; // annotated agentic method (e.g., @ParallelAgent)

    @Override
    public Workflow descriptor() {
        return workflow()
                .tasks(function("planEvening", eveningPlanner::plan, Agents.EveningPlan.class)
                        .outputAs("$.plan"),
                    post("notify", "https://example.org/notify"),
                    emitJson("org.acme.plan.created", Agents.EveningPlan.class))
               .build();
    }
}
----

This keeps LangChain4j’s semantics for the agentic pattern (including `AgenticScope` and `@Output` mappers),
while letting Quarkus Flow orchestrate the broader business process.

== 5. Compare: calling agents directly vs running generated workflows

You can still inject and use the agents in your own code:

[source,java]
----
@Inject
Agents.StoryCreatorWithConfigurableStyleEditor storyCreator;

@Inject
Agents.EveningPlannerAgent eveningPlanner;

public void demo() {
    String story = storyCreator.write("Quarkus", "sci-fi", "developers");
    Agents.EveningPlan plan = eveningPlanner.plan("Toronto", Agents.Mood.ROMANTIC);
}
----

The important point:

* When you call the agent method directly, Quarkus LangChain4j manages the `AgenticScope`
and agent orchestration.
* When you run the generated workflow from the Dev UI, Quarkus Flow executes the same agentic logic
via the agent bean, but adds:
** Auto-generated forms from the derived input schema.
** Mermaid diagrams and workflow topology visualization.
** Workflow traces/telemetry and a workflow execution surface (instances, debugging, etc.).

== 6. Why use Quarkus Flow on top of Quarkus LangChain4j?

Using Quarkus Flow on top of Quarkus LangChain4j gives you:

* A **runtime control plane** for your agentic workflows:
** Visual topology.
** Rich traces and logs.
** Instance-level inspection.
* **Better experimentation/debugging** via Dev UI with realistic inputs (including non-happy paths).
* **Easier integration** with the rest of your system:
** Chain agentic workflows with HTTP, messaging, listen/emit gates, etc.
** Use the same workflow engine for non-AI processes.

In short: you keep the ergonomic LC4J agent APIs, and Quarkus Flow turns them into
production-grade workflows with Dev UI, telemetry, and robustness.

== See also

* xref:langchain4j.adoc[] — orchestrate LangChain4j agents as Java DSL tasks.
* xref:concepts-agentic-langchain4j.adoc[] — how the annotations integration works internally.
